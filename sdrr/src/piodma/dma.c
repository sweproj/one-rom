// Copyright (C) 2026 Piers Finlayson <piers@piers.rocks>
//
// MIT License

// RP2350 DMA helper functions and notes

// RP2350 DMA Notes
//
// The RP2350's datasheet uses the terms "triggering" and "pacing" and I
// found it a bit vague and unintuitive.  Specifically "triggering", in
// datasheet terms, does NOT necessaarily cause a DMA transfer to occur.
// The channel has to be "paced" as well.
// 
// Hence I've have here described DMA it with the concepts of arming and
// triggering, with triggering differing slightly from the datasheet's
// usage.  I find the firearm analogy more useful.
//
// There are three ways to _arm_ a DMA channel:
// - Set the transfer_count to a non-zero value.
// - Write to a _TRIG register associated with the channel.
// - Chain to a channel from another channel.
//
// You must also enable the channel.
//
// In terms of _triggering_ a DMA channel, that is causing it to actually
// "fire", there are essentially three options:
// - Have it trigger by a DREQ signal, which is generated by another
//   peripheral like a PIO RX or TX FIFO.
// - Have it trigger off a timer.
// - Have it trigger off an arming event.
//
// The datasheet describes the trigger here as "pacing" the DMA.
//
// The transfer_count decrements after each "firing" (i.e. trigger event)
// and the DMA "fires" until the transfer_count reaches zero.
//
// Once it resets zero, it can be manually reset (i.e. the value changed),
// or it can be automatically reset by re-arming it - i.e. one of the
// re-arming mechanisms described above, or mode 0x1 below.
//
// The top nibble of the transfer_count has special meanings on the RP2350:
// - 0x0 - Normal operation
// - 0x1 - Immediately resets transfer_count back to its original value
// - 0xf - Never decrement transfer_count (i.e. infinite)
//
// Note that 0xf000_0000 never runs - as while the transfer_count never
// decrements, it is still initially zero.
//
// Chaining to another channel has an interesting configuration mechanism.
// The channel to be chained to is configured within the CTRL_TRIG
// register.  A value of this channel disables chaining.  To chain a
// channel to itself is done via a transfer_count of 0xfxxx_xxxx.
//
// There is a gotcha here.  Chaining to channel 0 is configured by a lack
// of setting the CHAIN_TO bits in CTRL_TRIG.  Hence, failing to set the
// CHAIN_TO bits means chain to channel 0.  This caused me no end of
// confusion not understanding why a DMA channel of 0 kept being re-armed.
// In fact, it was being chained to by channel 1, through a lack of
// explicitly configuring the CHAIN_TO bits within it.  When I added
// channels 2&3 for RAM WRITEs, I didn't understand why, instead I needed
// explicit chaining or a transfer_count of 0xfxxx_xxxx to get the DMA to
// run forever.  The datasheet does flag this within the CTRL_TRIG
// description:
//
// "Note this field resets to 0, so channels 1 and above will chain to
// channel 0 bydefault. Set this field to avoid this behaviour."
//
// IRQ_QUIET is set to avoid IRQs being raised each time transfer_count
// reaches zero.  This is not strictly required, as this firmware doesn't
// service those interrupts, but is cleaner.
//
// There is also the concept of DMA priorities - each channel can be normal
// or high priority.  All high priority channels and a maximum of one low
// priority channel will be scheduled in each cycle _if there is DMA
// saturation_.
//
// This description ignores the read and write incrementing modes, and ring
// buffer support, as they are not used by One ROM.

// RAM Serving DMA Configuration Notes
//
// Each of the RAM READ and WRITE operations use a chain of two DMAs.  The
// first DMA in each chain reads the target RAM address from the appropriate
// PIO RX FIFO and writes it to the second DMA's ADDR_TRIG register, which
// arms it.  The second DMA then performs the actual data transfer to or
// from the RAM table in SRAM, using another PIO FIFO as the source or
// destination.
//
// The first DMA in each chain is triggered by it's address reader PIO
// pushing an address to its RX FIFO.
//
// The READ chain is driven by its PIO continuously - that PIO tends to sit
// in a tight loop readig and pushing.  That PIO has strategic NOPs to
// avoid overloading the DMA chain.  It might seem counterintuitive to run
// this chain continuously, even when data is being written, but as the
// data lines are only set to outputs when /CE and /OE are both low, it
// does not interfere with RAM WRITEs, although see the next paragraph.
//
// The WRITE chain is configured as high priority, to ensure that, if there
// is contention, it gets serviced before the READ chain.  Contention is
// relatively likely, becaus the READ chain runs continuously, even when
// the RAM is in WRITE mode.  Hence when in WRITE mode, the READ chain's
// DMA may be trying to access the SRAM at the same time as the WRITE
// chain.  Setting the WRITE chain to high priority helps ensure that the
// WRITE gets serviced first, reducing the chance of the READ DMA causing
// delays to the WRITE operation.

#include "include.h"

#if defined(RP235X)

#endif // RP235X
// Contains configuration definitions and types which are used by the
// configuration generated by `sdrr-gen`. 

// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

#ifndef CONFIG_BASE_H
#define CONFIG_BASE_H

#include <stdint.h>

// Pull in enums
#include "enums.h"

// Pin allocations
//
// All pin numbers are physical pins - allocated from the configured STM32F4
// port.  Valid numbers are 0-15 on the STM32, 0-29 on the RP2350.
// 255 indicates a particular pin is present.
// The index into the array is ROM Address x or Data x number.
#define INVALID_PIN  255
typedef struct {
    // SDRR MCU pin port locations
    // Offset: 0
    // 8 x 1 byte = 8 bytes
    sdrr_mcu_port_t data_port;  // Data lines
    sdrr_mcu_port_t addr_port;  // Address lines
    sdrr_mcu_port_t cs_port;    // Chip select/enable lines
    sdrr_mcu_port_t sel_port;   // Image select jumpers
    sdrr_mcu_port_t status_port; // Status LED
    uint8_t chip_pins;           // Number of pins this chip is emulating 
    uint8_t bit_modes_t;        // Supported bit modes
    uint8_t reserved1[1];

    // 8 data lines
    // Offset: 8
    // 8 bytes
    uint8_t data[8];

    // Up to 16 address lines.  0xFF indicates unused line.
    // Offset: 16
    // 20 x 1 byte = 20 bytes
    uint8_t addr[16];
    uint8_t reserved2[4];

    // Chip select lines for supported variants
    //
    // x_jumper_pull is the direction of pull from the X1/X2 jumper on the
    // board.  It is 1 if that jumper closing pulls it high, and 0 if it pulls
    // it low.
    //
    // Offset: 36
    // 16 x 1 byte = 16 bytes
    uint8_t cs1;
    uint8_t cs2;
    // 3rd CS line, only used on 2316 and 23128, actually 2316's CS2, as 2316's CS3 is 2332's CS2
    uint8_t cs3;
    uint8_t reserved2a[1];
    uint8_t reserved2b[1];
    uint8_t reserved2c[1];
    uint8_t x1;
    uint8_t x2;
    uint8_t ce;
    uint8_t oe;
    uint8_t x_jumper_pull;
    uint8_t reserved3[3];

    // As of 0.6.0
    uint8_t swclk_sel;  // SWCLK connected to which sel pin (255 = none)
    uint8_t swdio_sel;  // SWDIO connected to which sel pin (255 = none)

    // Image select lines
    //
    // Sel jumper pull is the direction of pull-up or pull-down when closing
    // the jumper on this board type.  If 1, closing the jumper pulls it up.
    // This is used by One ROM to decide what type of its own pulls to apply
    // (the opposite).  Closing is always interpreted as a 1 by One ROM.
    //
    // As of 0.6.0, sel_jumper_pin is a bit field, with one byte per pin, to
    // allow for different pull directions per pin.  LSB = pin 0.
    //
    // Unused image select pins are set to 255.
    //
    // The order of pins in this array is significant - [0] is bit 0 of the
    // interpreted value, [1] bit 1, etc.  If a pin is missing (255) mid
    // array, the _next_ entry will be missing bit.
    //
    // Offset: 52
    // 8 bytes
#define MAX_IMG_SEL_PINS 7
    uint8_t sel[MAX_IMG_SEL_PINS];
    uint8_t sel_jumper_pull;

    // Status LED line
    // Offset: 60
    // 4x1 byte = 4 byte
    uint8_t status;
    uint8_t reserved5[2];

    // As of 0.6.2 - if it contains a 1, this structure is 256 bytes in size,
    // and the fields that follow are present.  As sdrr_pins_t is built into
    // the firmware, it does not bother to check for this.  From 0.6.2
    // sdrr_pins_t is always extended, hence this is set to 1.  It is used,
    // however, by sdrr-fw-parser and sdrr-info to detect the presence of the
    // extended pin attributes (although it can infer its presence from the
    // firmware version as well).
    uint8_t extended;

    // Length: 256, extended from 64 in 0.6.2

    // Additional data pins for 16-bit mode, in addition to the first 8 data pins.
    uint8_t data2[8];

    // Additional address pins, for > 64KB ROMs, in addition to the first 16 
    // address pins.
    uint8_t addr2[16];

    // Set by sdrr_gen to 0
    uint8_t reserved6[168];

} sdrr_pins_t;
_Static_assert(sizeof(sdrr_pins_t) == 256, "sdrr_pins_t must be 256 bytes");

// Forward declarations
struct onerom_metadata_header_t;
struct sdrr_runtime_info_t;

// Extra information stored in flash
typedef struct {
    // Pointer to RTT control block
    const void *rtt;

    // Whether USB DFU is supported
    uint8_t usb_dfu;
    // Which GPIO port USB pins are located on
    sdrr_mcu_port_t usb_port;
    // Pin number for VBUS detection
    uint8_t vbus_pin;
    // Whether PIO mode is set by default on Fire
    // Modified from reserved in 0.6.0
    uint8_t fire_pio_default;

    // Added in 0.5.10
    const struct sdrr_runtime_info_t* runtime_info;

    // Padding to make 256 bytes long
    uint8_t _post[244];
} sdrr_extra_info_t;
#if !defined(TEST_BUILD)
_Static_assert(sizeof(sdrr_extra_info_t) == 256, "sdrr_extra_info_t must be 256 bytes");
#endif // !TEST_BUILD

// Main SDRR information data structure
typedef struct {
    // Magic bytes to identify the firmware and structure
    // Offset: 0
    // 4 bytes
    const char magic[4];  // Magic bytes = "SDRR"

    // Firmware version information
    // Offset: 4
    // 4 x 2 bytes = 8 bytes
    const uint16_t major_version;
    const uint16_t minor_version;
    const uint16_t patch_version;
    const uint16_t build_number;

    // Pointer to build date/time string
    // Offset: 12
    // 4 bytes
    const char* build_date;

    // Git commit hash, NULL terminated
    // Offset: 16
    // 8 bytes
    char commit[8];

    // Hardware revision - pointer to string
    // Offset: 24
    // 4 bytes
    const char* hw_rev;

    // MCU product line
    // Offset: 28
    // 2 x 2 bytes = 4 bytes
    const mcu_line_t mcu_line;
    const mcu_storage_t mcu_storage;

    // Target frequency in MHz
    // Offset: 32
    // 2 + 1 bytes = 3 bytes
    const uint16_t freq;
    const uint8_t overclock;

    // Enable SWD support
    // Offset: 35
    // 1 byte
    const uint8_t swd_enabled;

    // Various debug options
    // Offset: 36
    // 5 x 1 bytes = 5 bytes
    const uint8_t preload_image_to_ram;
    const uint8_t bootloader_capable;
    const uint8_t status_led_enabled;
    const uint8_t boot_logging_enabled;
    const uint8_t mco_enabled;

    // Padding.
    //
    // In pre-v0.5.0 firmware, this was used as the number of ROM sets in the
    // firmware.  We now indicate that within the metadata header.
    // Offset: 41
    // 1 byte
    const uint8_t deprecated_rom_set_count;

    // Whether access count is enabled
    // Offset: 42
    // 1 byte
    const uint8_t count_rom_access;

    // Reserved for future use
    const uint8_t pad2[1];
    
    // Pointer to metadata.
    //
    // In pre-v0.5.0 firmware versions this was used as a pointer to rom_sets.
    // We have now added an additional structure and redirection to rom_sets,
    // pointing to them within the metadata header.  
    //
    // Offset: 44
    // 4 bytes
    const struct onerom_metadata_header_t *metadata_header;

    // Pin allocation structure
    // Offset: 48
    // 4 bytes
    const sdrr_pins_t *pins;

    // Boot configuration.  This is for future use.  For example, an external
    // programmer may change this value, and the SDRR firmware check it on
    // boot, and decide to pre-select an image based on it, rather than the
    // sel jumpers.
    // 
    // As such this is reserved and must be set to 0xff.
    //
    // Offset: 52
    // 4 bytes
    const uint8_t boot_config[4];

    // 56 bytes to here

    // v0.4.0 beyond here
    
    // Pointer to RTT control block
    const sdrr_extra_info_t *extra;

    // 4 further bytes
    uint8_t _post[4];

    // Length: 64
} sdrr_info_t;
#if !defined(TEST_BUILD)
_Static_assert(sizeof(sdrr_info_t) == 64, "sdrr_info_t must be 64 bytes");
#endif // !TEST_BUILD

// ROM image sizes by type (F1 family)
#define ROM_IMAGE_SIZE_2316  2048
#define ROM_IMAGE_SIZE_2332  4096
#define ROM_IMAGE_SIZE_2364  8192

// Maximum ROM image size (F4 family uses a single size for all ROM types)
#define ROM_IMAGE_SIZE_STM32F4  16384
#define ROM_IMAGE_SIZE_STM32F4_28PIN 65536
#define ROM_IMAGE_SIZE_RP235X   65536

// ROM image size for sets of more than 1 ROM image
#define ROM_SET_IMAGE_SIZE  65536

// ROM serving algorithm
typedef enum {
    // Original ROM serving algorithm - tests the chip select state(s) twice
    // as often as it loads the ROM data given the address lines state.  This
    // is the default algorithm, and is used for all single ROM sets.
    SERVE_TWO_CS_ONE_ADDR,

    // Serves the byte from RAM only once chip select line(s) active.
    // Very similar to SERVE_ADDR_ON_ANY_CS - but this only matches on all
    // of the required CS lines, that matches on any, so is suitable for
    // multiple ROM sets.
    SERVE_ADDR_ON_CS,

    // Serves the byte from RAM once any of the chip select lines are active.
    // This is used for sets with multiple ROM images, where we don't know the
    // full address (i.e. the image to lookup from) until any of the chip
    // select lines are active.  This is the default algorithm for sets with
    // multiple ROM images on hardware revision F.
    SERVE_ADDR_ON_ANY_CS,
} sdrr_serve_t;
#define SERVE_DEFAULT_1_ROM  SERVE_ADDR_ON_CS
_Static_assert(sizeof(sdrr_serve_t) == 1, "sdrr_serve_t must be 1 byte");

// ROM information structure
typedef struct {
    const sdrr_rom_type_t rom_type;     // ROM type
    const sdrr_cs_state_t cs1_state;    // CS1 state
    const sdrr_cs_state_t cs2_state;    // CS2 state
    const sdrr_cs_state_t cs3_state;    // CS3 state
    const char* filename;               // Source filename (May be NULL)
} sdrr_rom_info_t;

// Firmware Overrides
//
// This is linked to via the ROM set structure, and allows per-ROM-set
// overrides of firmware configuration options.
//
// Where each ROM set requires the same overrides, only once instance of this
// structure need be created, and all ROM sets can point to it.
typedef struct {
    // Bitfield indicating which overrides are present.
    //
    // Table below shows byte | bit, where bit 0 = LSB.
    // A set bit indicates that the corresponding override is configured.
    //
    // 0 | 0 = Ice MCU frequency
    // 0 | 1 = Ice overclock overridden
    // 0 | 2 = Fire MCU frequency
    // 0 | 3 = Fire overclock overridden
    // 0 | 4 = Fire VREQ overridden
    // 0 | 5 = Status LED overridden
    // 0 | 6 = SWD overridden
    // 0 | 7 = Fire serve mode overridden
    // 
    // Unused (reserved) values MUST be set to 0.
    const uint8_t override_present[8];

    // 8 bytes to here

    // STM32F4 (Ice) MCU clock frequency override in MHz.  0 = max rated clock
    // speed for the MCU.
    const ice_freq_t ice_freq;

    // RP2350 (Fire) MCU clock frequency override in MHz.  Uses values from
    // fire_freq_t enum.
    const fire_freq_t fire_freq;

    // RP2350 (Fire) VREQ voltage override.  Uses values for VREQ_CTRL
    // register.
    const fire_vreg_t fire_vreg;

    const uint8_t pad1[3];

    // 16 bytes to here

    // Bitfields indicating boolean values for specific overrides
    //
    // Byte | Bit : Description, bit 0 = LSB
    // 0 | 0 : Ice overclocking enabled/disabled 1/0
    // 0 | 1 : Fire overclocking enabled/disabled 1/0
    // 0 | 2 : Status LED enabled/disabled 1/0
    // 0 | 3 : SWD enabled/disabled 1/0
    // 0 | 4 : Fire serve mode: 1 = PIO, 0 = CPU
    const uint8_t override_value[8];

    // 24 bytes to here

    // Padding to 64 bytes
    const uint8_t pad3[40];
} onerom_firmware_overrides_t;

// Serving algorithm configuration structure
//
// Reserves 64 bytes for configuration data for the serving algorithm.
//
// Padded with 0xff for unused bytes.
typedef struct {
    uint8_t reserved[64];
} onerom_serve_config_t;

// ROM set information structure
//
// SDRR can serve sets of ROM images, which are addressed using the entirety
// of the STM32F4 port C.  This is done in order to emulate multuple ROMs
// simultaneously, with  the additional ROM select lines attached to SDRR via
// X1 and X2.
//
// If the multiple ROM image support is not used, there is a 1:1 mapping
// between set and image - i.e. `rom_count` is be 1.
typedef struct sdrr_rom_set_t {
    // Pointer to the data for the ROM image(s) in this set.  Copied to RAM at
    // startup.
    const uint8_t* data;

    // Size of the data for the ROM image(s) in this set.  Used to copy the
    // ROM data to RAM at startup.  This is either:
    // - ROM_IMAGE_SIZE for a single ROM image
    // - ROM_SET_IMAGE_SIZE for a set of multiple ROM images
    const uint32_t size;

    // Pointer to array of pointers to ROMs in this set.  Note it needs to be
    // a pointer to const pointer to const data, otherwise the linker will
    // decide that the sdrr_rom_info_t structs need to be relocated to RAM
    // on startup, which is unnecessary. 
    const sdrr_rom_info_t* const * roms;

    // The number of unique ROM images in this set.  Used to index the above
    // array.
    const uint8_t rom_count;

    // Which ROM serving algorithm to use for this set.
    const sdrr_serve_t serve;         // ROM serving algorithm

    // CS1 state (active high/low) when using multiple ROM images in this set
    const sdrr_cs_state_t multi_rom_cs1_state;  // CS1 state

    // Whether 0.6.0 onwards firmware extra info (the subsequent fields) are
    // present in this structure. If so, this is set to 1.  Note that even if
    // those fields are not filled in, this is 1 - this is essentially used
    // to indicate the side of the sdrr_rom_set_t structure being used.
    const uint8_t extra_info;

    // Beyond here 0.6.0 firmware onwards

    // Pointer to configuration data for the serving algorithm.
    const onerom_serve_config_t *serve_config;

    // Pointer to firmware configuration overrides when serving this ROM set.
    const onerom_firmware_overrides_t *firmware_overrides;

    // Padding to 64 bytes
    const uint8_t pad2[40];
} sdrr_rom_set_t;

// SDRR Runtime Information Structure
//
// Contains information about the SDRR runtime environment.
typedef struct sdrr_runtime_info_t {
    // Magic bytes to identify the firmware and structure
    // Offset: 0
    // 4 bytes
    char magic[4];  // Magic bytes = "SDRR"

    // Size of this structure in bytes
    // Offset: 4
    // 1 byte
    uint8_t runtime_info_size;

    // Image select jumper state at boot.
    // Initialized to 0xFF.
    // Offset: 5
    // 1 byte
    uint8_t  image_sel;

    // Index of the currently selected ROM set.  This is chosen at boot via
    // the image select jumpers.
    // Initialized to 0xFF.
    // Offset: 6
    // 1 byte
    uint8_t rom_set_index;

    // Whether the ROM access counting feature is enabled.
    // Initialized to 0x00.
    // Offset: 7
    // 1 byte
    uint8_t count_rom_access;

    // Counter for the number times the CS lines have transitioned from
    // inactive to active.  This is only updated if COUNT_ROM_ACCESS is
    // defined in the configuration.  This field is unused (but present) if
    // COUNT_ROM_ACCESS is not defined.
    // Initialized to 0xFFFFFFFF.  Only set to 0x00000000 if COUNT_ROM_ACCESS
    // is defined, when the ROM starts serving.
    // Offset: 8
    // 4 bytes
    uint32_t access_count;

    // Pointer to the ROM table SDRR uses to serve the ROM data this run
    // Initialized to null.
    // Offset: 12
    // 4 bytes
    void *rom_table;

    // Length of the ROM table SDRR is serving in bytes.
    // Initialized to 0.
    // Offset: 16
    // 4 bytes
    uint32_t rom_table_size;

    // Whether to enter DFU mode - STM32 only.
    // Offset: 20
    //
    // 0x21554644 ("DFU!" little endian) enters bootloader
#define ENTER_BOOTLOADER_MAGIC 0x21554644
    uint32_t bootloader_entry;

    // Following added in 0.6.0

    // Whether overlocking is enabled
    // Offset: 24
    uint8_t overclock_enabled;

    // Whether status LED is enabled
    // Offset: 25
    uint8_t status_led_enabled;

    // Whether SWD is enabled
    // Offset: 26
    uint8_t swd_enabled;

    // Fire VREG output setting
    // Offset: 27
    fire_vreg_t fire_vreg;

    // Ice frequency setting
    // Offset: 28
    ice_freq_t ice_freq;

    // Fire frequency setting
    // Offset: 30
    fire_freq_t fire_freq;

    // SYSCLK frequency in MHz
    // Offset: 32
    uint16_t sysclk_mhz;

    // Use PIO serving mode on Fire
    // Changed in 0.6.2 from uint8_t (PIO = 1) to fire_serve_modes_t
    // Offset: 34
    fire_serve_modes_t fire_serve_mode;

    // Bit mode - v0.6.2
    // Offset: 35
    bit_modes_t bit_mode;

    // Length = 36 bytes
} sdrr_runtime_info_t;

// One ROM Metadata Header
//
// Placed at the start of the metadata flash area to indicate:
// - metadata version
// - location of the actual metadata
typedef struct onerom_metadata_header_t {
    // Magic bytes to identify the metadata header
    //
    // Offset: 0
    const char magic[16];  // "ONEROM_METADATA\0"

    // Metadata version
    //
    // Offset: 16
    const uint32_t version; // Metadata version - currently 1

    // Number of installed ROM sets
    // 
    // Offset: 20
    const uint8_t rom_set_count;
    const uint8_t pad1[3];

    // Pointer to array of ROM sets (also in metadata section)
    //
    // Offset: 24
    const sdrr_rom_set_t *rom_sets;

    // Reserved for future expansion, preferably set to 0xff.
    //
    // Offset: 28
    const uint8_t reserved[228];

} onerom_metadata_header_t;

#endif // CONFIG_BASE_H
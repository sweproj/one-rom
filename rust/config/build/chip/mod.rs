// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

use std::fs;
use std::path::Path;

mod doc;
mod validation;

use validation::{ControlLineType, ChipType, ChipTypesConfig, ChipFunction};

pub const CHIP_TYPES_JSON_FILENAME: &str = "json/chip-types.json";
pub const CHIP_GENERATED_RS_FILENAME: &str = "chip/generated.rs";
pub const CHIP_MOD_RS_FILENAME: &str = "chip/mod.rs";
pub const CHIP_DOCS_MD_FILENAME: &str = "CHIP-TYPES.md";

pub fn build(manifest_path: &Path) {
    // Construct path to JSON config
    let json_path = manifest_path.join(CHIP_TYPES_JSON_FILENAME);

    // Tell Cargo to rerun only if the JSON config changes
    println!("cargo:rerun-if-changed={}", json_path.display());

    // Read and validate the configuration
    let json = fs::read_to_string(&json_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", json_path.display(), e));

    let config = ChipTypesConfig::from_json(&json)
        .unwrap_or_else(|e| panic!("Failed to parse or validate {}: {}", json_path.display(), e));

    // Generate Rust code for types and implementations
    let generated_code = generate_rust_code(&config);

    // Generate lib.rs with documentation
    let lib_code = generate_lib_rs(&config);

    // Generate markdown docs
    let markdown = doc::generate_chip_types_markdown(&config);

    // Write src/chip/generated.rs
    let src_path = manifest_path.join("src").join(CHIP_GENERATED_RS_FILENAME);
    fs::write(&src_path, &generated_code)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", src_path.display(), e));

    // Write src/chip/mod.rs
    let mod_path = manifest_path.join("src").join(CHIP_MOD_RS_FILENAME);
    fs::write(&mod_path, &lib_code)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", mod_path.display(), e));

    // Write docs/chip-types.md
    let docs_path = manifest_path
        .join("..")
        .join("..")
        .join("docs")
        .join(CHIP_DOCS_MD_FILENAME);
    fs::create_dir_all(docs_path.parent().unwrap())
        .unwrap_or_else(|e| panic!("Failed to create docs directory: {}", e));
    fs::write(&docs_path, &markdown)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", docs_path.display(), e));

    eprintln!("Documentation generated at {}", docs_path.display());
}

fn get_sorted_chip_types(config: &ChipTypesConfig) -> Vec<(&String, &ChipType)> {
    let mut types: Vec<_> = config.chip_types.iter().collect();
    // Sort by: pin count, then size, then name (for determinism)
    types.sort_by_key(|(name, chip_type)| (chip_type.pins, chip_type.size, *name));
    types
}

fn generate_lib_rs(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("// AUTO-GENERATED by build/main.rs - DO NOT EDIT MANUALLY\n");
    code.push_str("// Generated from hw-config/chip-types.json\n");
    code.push_str("//\n");
    code.push_str("// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>\n");
    code.push_str("// MIT License\n\n");

    code.push_str("//! Chip type configurations for One ROM\n");
    code.push_str("//!\n");
    code.push_str(
        "//! This module provides compile-time Chip chip specifications for retro computing\n",
    );
    code.push_str("//! systems. All data is generated at build time from JSON configuration and\n");
    code.push_str("//! embedded as const data - no runtime parsing or allocations needed.\n");
    code.push_str("//!\n");
    code.push_str(
        "//! It is primarily intended for use by the One ROM firmware tooling, but may be\n",
    );
    code.push_str("//! useful in other embedded or WASM projects related to One ROM, such as\n");
    code.push_str("//! Airfrog.\n");
    code.push_str("//!\n");
    code.push_str(
        "//! Note that the presence of Chip types in this crate does not imply that they are\n",
    );
    code.push_str(
        "//! supported by all (or even any!) One ROM hardware versions. Please check the\n",
    );
    code.push_str("//! One ROM documentation for supported Chip types.\n");
    code.push_str("//!\n");
    code.push_str("//! # Supported Chip Types\n");
    code.push_str("//!\n");

    // Group Chips by type for documentation
    let mut mask_24pin = Vec::new();
    let mut mask_28pin = Vec::new();
    let mut mask_32pin = Vec::new();
    let mut mask_40pin = Vec::new();
    let mut eprom_24pin = Vec::new();
    let mut eprom_28pin = Vec::new();
    let mut eprom_32pin = Vec::new();
    let mut eprom_40pin = Vec::new();
    let mut ram_chips = Vec::new();

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            let entry = format!(
                "//! - **{}**: {} ({})\n",
                type_name,
                chip_type
                    .description
                    .split(" with ")
                    .next()
                    .unwrap_or(&chip_type.description),
                chip_type
                    .description
                    .split(" with ")
                    .nth(1)
                    .unwrap_or("see datasheet")
            );

            if type_name.starts_with("23") && chip_type.function == ChipFunction::Rom {
                if chip_type.pins == 24 {
                    mask_24pin.push(entry);
                } else if chip_type.pins == 28 {
                    mask_28pin.push(entry);
                } else if chip_type.pins == 32 {
                    mask_32pin.push(entry);
                } else if chip_type.pins == 40 {
                    mask_40pin.push(entry);
                } else {
                    panic!(
                        "Unexpected pin count {} for mask ROM {}",
                        chip_type.pins, type_name
                    );
                }
            } else if type_name.starts_with("27") && chip_type.function == ChipFunction::Rom {
                if chip_type.pins == 24 {
                    eprom_24pin.push(entry);
                } else if chip_type.pins == 28 {
                    eprom_28pin.push(entry);
                } else if chip_type.pins == 32 {
                    eprom_32pin.push(entry);
                } else if chip_type.pins == 40 {
                    eprom_40pin.push(entry);
                } else {
                    panic!(
                        "Unexpected pin count {} for EPROM {}",
                        chip_type.pins, type_name
                    );
                }
            } else if chip_type.function == ChipFunction::Ram {
                ram_chips.push(entry);
            } else {
                panic!("Unsupported chip type {} - needs adding", type_name);
            }
        }
    }

    if !mask_24pin.is_empty() {
        code.push_str("//! ## 24-pin Mask ROMs (23xx series)\n");
        for entry in mask_24pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !mask_28pin.is_empty() {
        code.push_str("//! ## 28-pin Mask ROMs (23xx series)\n");
        for entry in mask_28pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !mask_32pin.is_empty() {
        code.push_str("//! ## 32-pin Mask ROMs (23xx series)\n");
        for entry in mask_32pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !mask_40pin.is_empty() {
        code.push_str("//! ## 40-pin Mask ROMs (23xx series)\n");
        for entry in mask_40pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !eprom_24pin.is_empty() {
        code.push_str("//! ## 24-pin EPROMs (27xx series)\n");
        for entry in eprom_24pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !eprom_28pin.is_empty() {
        code.push_str("//! ## 28-pin EPROMs (27xx series)\n");
        for entry in eprom_28pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !eprom_32pin.is_empty() {
        code.push_str("//! ## 32-pin EPROMs (27Cxx series)\n");
        for entry in eprom_32pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !eprom_40pin.is_empty() {
        code.push_str("//! ## 40-pin EPROMs (27Cxx series)\n");
        for entry in eprom_40pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !ram_chips.is_empty() {
        code.push_str("//! ## RAM Chips\n");
        for entry in ram_chips {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    code.push_str("//! # Usage\n");
    code.push_str("//!\n");
    code.push_str("//! ```\n");
    code.push_str("//! use onerom_config::chip::{ChipType, ControlLineType};\n");
    code.push_str("//!\n");
    code.push_str("//! // Get Chip specifications\n");
    code.push_str("//! let chip = ChipType::Chip2364;\n");
    code.push_str("//! assert_eq!(chip.size_bytes(), 8192);\n");
    code.push_str("//! assert_eq!(chip.chip_pins(), 24);\n");
    code.push_str("//! assert_eq!(chip.num_addr_lines(), 13);\n");
    code.push_str("//!\n");
    code.push_str("//! // Get pin mappings\n");
    code.push_str("//! let addr_pins = chip.address_pins();\n");
    code.push_str("//! let data_pins = chip.data_pins();\n");
    code.push_str("//! println!(\"A0 is on pin {}\", addr_pins[0]);\n");
    code.push_str("//! println!(\"D0 is on pin {}\", data_pins[0]);\n");
    code.push_str("//!\n");
    code.push_str("//! // Check control lines\n");
    code.push_str("//! let control = chip.control_lines();\n");
    code.push_str("//! assert_eq!(control.len(), 1);\n");
    code.push_str("//! assert_eq!(control[0].name, \"cs1\");\n");
    code.push_str("//! assert_eq!(control[0].line_type, ControlLineType::Configurable);\n");
    code.push_str("//!\n");
    code.push_str("//! // Parse from string\n");
    code.push_str("//! if let Some(chip) = ChipType::try_from_str(\"27128\") {\n");
    code.push_str("//!     println!(\"Found Chip: {}\", chip.name());\n");
    code.push_str("//! }\n");
    code.push_str("//! ```\n");
    code.push_str("//!\n");
    code.push_str("//! # Features\n");
    code.push_str("//!\n");
    code.push_str("//! - **Zero runtime cost**: All data is const, compiled into your binary\n");
    code.push_str("//! - **no_std and no allocations**: Perfect for embedded systems and WASM\n");
    code.push_str("//! - **Type safe**: Enum-based API prevents invalid Chip type references\n");
    code.push_str("//! - **Validated**: Build fails if JSON config is invalid\n");
    code.push_str("//!\n");
    code.push_str("//! # Architecture\n");
    code.push_str("//!\n");
    code.push_str("//! This crate uses the build/main.rs script to:\n");
    code.push_str("//! 1. Read `hw-config/chip-types.json` from the repository root\n");
    code.push_str("//! 2. Validate all Chip specifications at build time\n");
    code.push_str("//! 3. Generate Rust const data structures\n");
    code.push_str("//! 4. Fail the build if validation errors occur\n");
    code.push_str("//!\n");
    code.push_str("//! The generated code is pure Rust with no dependencies, making it suitable\n");
    code.push_str("//! for use in no_std environments, WASM, and any Rust project.\n\n");

    code.push_str("#![deny(missing_docs)]\n");
    code.push_str("#![deny(unsafe_code)]\n\n");

    code.push_str("mod generated;\n\n");
    code.push_str("pub use generated::*;\n");

    code
}

fn generate_rust_code(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    // File header
    code.push_str("// AUTO-GENERATED by build/main.rs - DO NOT EDIT MANUALLY\n");
    code.push_str("// Generated from hw-config/chip-types.json\n");
    code.push('\n');
    code.push_str("// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>\n");
    code.push_str("//\n");
    code.push_str("// MIT License\n\n");
    code.push_str("#![allow(dead_code)]\n\n");

    // Generate chip function type enum
    code.push_str(generate_chip_function_enum());
    code.push_str("\n\n");

    // Generate control line type enum
    code.push_str(generate_control_line_type_enum());
    code.push_str("\n\n");

    // Generate control line spec struct
    code.push_str(generate_control_line_spec_struct());
    code.push_str("\n\n");

    // Generate programming pin spec struct
    code.push_str(generate_programming_pin_spec_struct());
    code.push_str("\n\n");

    // Generate power pin spec struct
    code.push_str(generate_power_pin_spec_struct());
    code.push_str("\n\n");

    // Generate ChipType enum
    code.push_str(&generate_chip_type_enum(config));
    code.push_str("\n\n");

    // Generate ChipType implementation
    code.push_str(&generate_chip_type_impl(config));

    code
}

fn generate_chip_function_enum() -> &'static str {
    r#"/// Chip function type
///
/// Defines the function of this chip (currently ROM or RAM).
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum ChipFunction {
    /// Read-Only Memory (ROM) chip
    #[serde(rename = "ROM")]
    Rom,
    
    /// Random-Access Memory (RAM) chip
    #[serde(rename = "RAM")]
    Ram,
}"#
}

fn generate_control_line_type_enum() -> &'static str {
    r#"/// Control line behavior type
///
/// Defines whether a control line is user-configurable (mask-programmable)
/// or fixed active-low per JEDEC standard.
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum ControlLineType {
    /// CS line with user-configurable polarity (23xxx series mask ROMs)
    ///
    /// These lines can be mask-programmed as either active-high or active-low
    /// during manufacturing. The user must specify the polarity in their configuration.
    Configurable,
    
    /// Fixed active-low control line (27xxx series EPROMs)
    ///
    /// These lines follow the JEDEC standard and are always active-low (/CE, /OE).
    FixedActiveLow,
}"#
}

fn generate_control_line_spec_struct() -> &'static str {
    r#"/// Specification for a single control line
///
/// Defines the physical pin number and behavior type for control signals
/// like chip select (CS), chip enable (CE), and output enable (OE).
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub struct ControlLineSpec {
    /// Signal name (e.g., "cs1", "ce", "oe")
    pub name: &'static str,
    
    /// Physical pin number on the Chip package
    pub pin: u8,
    
    /// Behavior type (configurable or fixed active-low)
    pub line_type: ControlLineType,
}"#
}

fn generate_programming_pin_spec_struct() -> &'static str {
    r#"/// Programming pin read state specification
///
/// Defines the required state for programming-related pins (Vpp, /PGM)
/// during normal read operations.
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum ProgrammingPinState {
    /// Pin must be at Vcc (5V)
    Vcc,
    
    /// Pin must be logic high
    High,
    
    /// Pin must be logic low  
    Low,
    
    /// Pin generates chip select (output enable) signal
    ///
    /// Used for shared /OE/VPP pins (e.g., 2732 pin 20) where the pin
    /// serves as output enable during read and VPP during programming.
    ChipSelect,

    /// Pin is ignored during read operations
    Ignored,

    /// Pin indicates word size (e.g., 8-bit vs 16-bit)
    WordSize,
}

/// Programming pin specification
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub struct ProgrammingPinSpec {
    /// Pin name (e.g., "vpp", "pgm", "oe_vpp")
    pub name: &'static str,
    
    /// Physical pin number on the Chip package
    pub pin: u8,
    
    /// Required state during read operations
    pub read_state: ProgrammingPinState,
}"#
}

fn generate_power_pin_spec_struct() -> &'static str {
    r#"/// Power pin specification
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub struct PowerPinSpec {
    /// Pin name ("vcc" or "gnd")
    pub name: &'static str,
    
    /// Physical pin number on the Chip package
    pub pin: u8,
}"#
}

fn generate_chip_type_enum(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("/// Chip type\n");
    code.push_str("///\n");
    code.push_str("/// Supported retrochip types with their pinouts and characteristics.\n");
    code.push_str("/// Includes mask ROMs (23xx series), EPROMs (27xx series) and RAM chips.\n");
    code.push_str("///\n");
    code.push_str("/// # Examples\n");
    code.push_str("///\n");
    code.push_str("/// ```\n");
    code.push_str("/// use onerom_config::chip::ChipType;\n");
    code.push_str("///\n");
    code.push_str("/// let chip = ChipType::Chip2364;\n");
    code.push_str("/// assert_eq!(chip.size_bytes(), 8192);\n");
    code.push_str("/// assert_eq!(chip.chip_pins(), 24);\n");
    code.push_str("/// assert_eq!(chip.num_addr_lines(), 13);\n");
    code.push_str("/// ```\n");
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize)]\n");
    code.push_str("#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n");
    code.push_str("pub enum ChipType {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name.as_str()) {
            code.push_str(&format!(
                "    /// {} - {} bytes, {}-pin package\n",
                chip_type.description, chip_type.size, chip_type.pins
            ));
            code.push_str(&format!(
                "    #[cfg_attr(feature = \"schemars\", schemars(rename = \"{type_name}\"))]\n"
            ));
            code.push_str(&format!("    Chip{},\n", type_name));
        }
    }

    code.push_str("}\n\n");

    code.push_str("impl<'de> serde::Deserialize<'de> for ChipType {\n");
    code.push_str("    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n");
    code.push_str("    where\n");
    code.push_str("        D: serde::Deserializer<'de>,\n");
    code.push_str("    {\n");
    code.push_str("        let s = <&str>::deserialize(deserializer)?;\n");
    code.push_str("        match s {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if config.chip_types.contains_key(type_name.as_str()) {
            code.push_str(&format!(
                "            \"Chip{}\" | \"{}\" => Ok(ChipType::Chip{}),\n",
                type_name, type_name, type_name
            ));
        }
    }

    code.push_str("            _ => Err(serde::de::Error::unknown_variant(\n");
    code.push_str("                s,\n");
    code.push_str("                &[");

    let type_names: Vec<String> = get_sorted_chip_types(config)
        .iter()
        .filter_map(|(type_name, _)| {
            if config.chip_types.contains_key(type_name.as_str()) {
                Some(format!("\"{}\"", type_name))
            } else {
                None
            }
        })
        .collect();
    code.push_str(&type_names.join(", "));

    code.push_str("],\n");
    code.push_str("            )),\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    code.push_str("/// All supported Chip types\n");
    code.push_str("pub const CHIP_TYPES: &[ChipType] = &[\n");
    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if config.chip_types.contains_key(type_name.as_str()) {
            code.push_str(&format!("    ChipType::Chip{},\n", type_name));
        }
    }
    code.push_str("];\n");

    code
}

fn generate_chip_type_impl(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("impl ChipType {\n");

    // Generate try_from_str
    code.push_str(&generate_try_from_str(config));
    code.push_str("\n\n");

    // Generate name
    code.push_str(&generate_name_method(config));
    code.push_str("\n\n");

    // Generate aliases
    code.push_str(&generate_aliases_method(config));
    code.push_str("\n\n");

    // Generate chip function
    code.push_str(&generate_chip_function_method(config));
    code.push_str("\n\n");

    // Generate bit modes
    code.push_str(&generate_bit_modes_method(config));
    code.push_str("\n\n");

    // Generate supports X bit mode
    code.push_str(&generate_supports_bit_mode_method(config));
    code.push_str("\n\n");

    // Generate c_enum_name
    code.push_str(&generate_c_enum_method(config));
    code.push_str("\n\n");

    // Generate chip_pins
    code.push_str(&generate_chip_pins_method(config));
    code.push_str("\n\n");

    // Generate size_bytes
    code.push_str(&generate_size_bytes_method(config));
    code.push_str("\n\n");

    // Generate num_addr_lines
    code.push_str(&generate_num_addr_lines_method(config));
    code.push_str("\n\n");

    // Generate address_pins
    code.push_str(&generate_address_pins_method(config));
    code.push_str("\n\n");

    // Generate data_pins
    code.push_str(&generate_data_pins_method(config));
    code.push_str("\n\n");

    // Generate control_lines
    code.push_str(&generate_control_lines_method(config));
    code.push_str("\n\n");

    // Generate programming_pins
    code.push_str(&generate_programming_pins_method(config));
    code.push_str("\n\n");

    // Generate power_pins
    code.push_str(&generate_power_pins_method(config));
    code.push_str("\n\n");

    code.push_str("}\n");

    // Display impl
    code.push('\n');
    code.push_str("impl core::fmt::Display for ChipType {\n");
    code.push_str("    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n");
    code.push_str("        write!(f, \"{}\", self.name())\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    code
}

fn generate_try_from_str(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Parse Chip type from string identifier\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::try_from_str(\"2364\"), Some(ChipType::Chip2364));\n");
    code.push_str(
        "    /// assert_eq!(ChipType::try_from_str(\"27128\"), Some(ChipType::Chip27128));\n",
    );
    code.push_str("    /// assert_eq!(ChipType::try_from_str(\"invalid\"), None);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub fn try_from_str(s: &str) -> Option<Self> {\n");
    code.push_str("        match s {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if config.chip_types.contains_key(type_name) {
            code.push_str(&format!(
                "            \"{}\" => Some(ChipType::Chip{}),\n",
                type_name, type_name
            ));
        }
    }

    code.push_str("            _ => None,\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_name_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get the Chip type name as a string\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::Chip2364.name(), \"2364\");\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn name(&self) -> &'static str {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if config.chip_types.contains_key(type_name) {
            code.push_str(&format!(
                "            ChipType::Chip{} => \"{}\",\n",
                type_name, type_name
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_aliases_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get any alternative names or aliases for this Chip type\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::Chip6116.aliases(), &[\"2016\"]);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn aliases(&self) -> &'static [&'static str] {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            let aliases = chip_type
                .aliases
                .as_ref()
                .map(|aliases| {
                    aliases
                        .iter()
                        .map(|alias| format!("\"{}\"", alias))
                        .collect::<Vec<String>>()
                        .join(", ")
                })
                .unwrap_or_default();
            code.push_str(&format!(
                "            ChipType::Chip{} => &[{}],\n",
                type_name, aliases
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_chip_function_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get the function type of this chip (ROM or RAM)\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::{ChipType, ChipFunction};\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::Chip2364.chip_function(), ChipFunction::Rom);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn chip_function(&self) -> ChipFunction {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            code.push_str(&format!(
                "            ChipType::Chip{} => ChipFunction::{},\n",
                type_name,
                match chip_type.function {
                    ChipFunction::Rom => "Rom",
                    ChipFunction::Ram => "Ram",
                }
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_bit_modes_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get supported bit modes for this Chip type\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::Chip2364.bit_modes(), &[8]);\n");
    code.push_str("    /// assert_eq!(ChipType::Chip27C400.bit_modes(), &[8, 16]);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn bit_modes(&self) -> &'static [u8] {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            let modes = chip_type
                .bit_modes
                .iter()
                .map(|mode| mode.to_string())
                .collect::<Vec<String>>()
                .join(", ");
            code.push_str(&format!(
                "            ChipType::Chip{} => &[{}],\n",
                type_name, modes
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_supports_bit_mode_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Check if this Chip type supports the given bit mode\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert!(ChipType::Chip27C400.supports_bit_mode(16));\n");
    code.push_str("    /// assert!(!ChipType::Chip2364.supports_bit_mode(16));\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn supports_bit_mode(&self, mode: u8) -> bool {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            let modes = chip_type
                .bit_modes
                .iter()
                .map(|mode| mode.to_string())
                .collect::<Vec<String>>()
                .join(" | ");
            code.push_str(&format!(
                "            ChipType::Chip{} => matches!(mode, {}),\n",
                type_name, modes
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_c_enum_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get the C enum name for this Chip type\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::Chip2364.c_enum_name(), \"CHIP_TYPE_2364\");\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn c_enum_name(&self) -> &'static str {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if config.chip_types.contains_key(type_name) {
            code.push_str(&format!(
                "            ChipType::Chip{} => \"CHIP_TYPE_{}\",\n",
                type_name, type_name
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_chip_pins_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get the number of pins in the Chip package\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::Chip2364.chip_pins(), 24);\n");
    code.push_str("    /// assert_eq!(ChipType::Chip27128.chip_pins(), 28);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn chip_pins(&self) -> u8 {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            code.push_str(&format!(
                "            ChipType::Chip{} => {},\n",
                type_name, chip_type.pins
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_size_bytes_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get Chip capacity in bytes\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::Chip2316.size_bytes(), 2048);\n");
    code.push_str("    /// assert_eq!(ChipType::Chip27512.size_bytes(), 65536);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn size_bytes(&self) -> usize {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            code.push_str(&format!(
                "            ChipType::Chip{} => {},\n",
                type_name, chip_type.size
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_num_addr_lines_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get number of address lines\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(ChipType::Chip2364.num_addr_lines(), 13); // 2^13 = 8192\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn num_addr_lines(&self) -> usize {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            code.push_str(&format!(
                "            ChipType::Chip{} => {},\n",
                type_name,
                chip_type.address.len()
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_address_pins_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get address line pin mapping\n");
    code.push_str("    ///\n");
    code.push_str(
        "    /// Returns an array where index is the logical address line number (A0, A1, ...)\n",
    );
    code.push_str("    /// and the value is the physical pin number on the Chip package.\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// let pins = ChipType::Chip2364.address_pins();\n");
    code.push_str("    /// assert_eq!(pins[0], 8);  // A0 is on pin 8\n");
    code.push_str("    /// assert_eq!(pins[12], 21); // A12 is on pin 21\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn address_pins(&self) -> &'static [u8] {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            let pins_str = chip_type
                .address
                .iter()
                .map(|p| p.to_string())
                .collect::<Vec<_>>()
                .join(", ");
            code.push_str(&format!(
                "            ChipType::Chip{} => &[{}],\n",
                type_name, pins_str
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_data_pins_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get data line pin mapping\n");
    code.push_str("    ///\n");
    code.push_str("    /// Returns an array where index is the logical data line number (D0-D7)\n");
    code.push_str("    /// and the value is the physical pin number on the Chip package.\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::ChipType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// let pins = ChipType::Chip2364.data_pins();\n");
    code.push_str("    /// assert_eq!(pins.len(), 8);\n");
    code.push_str("    /// assert_eq!(pins[0], 9);  // D0 is on pin 9\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn data_pins(&self) -> &'static [u8] {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            let pins_str = chip_type
                .data
                .iter()
                .map(|p| p.to_string())
                .collect::<Vec<_>>()
                .join(", ");
            code.push_str(&format!(
                "            ChipType::Chip{} => &[{}],\n",
                type_name, pins_str
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_control_lines_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get control line specifications\n");
    code.push_str("    ///\n");
    code.push_str("    /// Returns control line specs for CS (chip select), CE (chip enable),\n");
    code.push_str("    /// and OE (output enable) signals.\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::{ChipType, ControlLineType};\n");
    code.push_str("    ///\n");
    code.push_str("    /// let lines = ChipType::Chip2364.control_lines();\n");
    code.push_str("    /// assert_eq!(lines.len(), 1);\n");
    code.push_str("    /// assert_eq!(lines[0].name, \"cs1\");\n");
    code.push_str("    /// assert_eq!(lines[0].line_type, ControlLineType::Configurable);\n");
    code.push_str("    ///\n");
    code.push_str("    /// let lines = ChipType::Chip27128.control_lines();\n");
    code.push_str("    /// assert_eq!(lines.len(), 2);\n");
    code.push_str("    /// assert!(lines.iter().any(|l| l.name == \"ce\"));\n");
    code.push_str("    /// assert!(lines.iter().any(|l| l.name == \"oe\"));\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn control_lines(&self) -> &'static [ControlLineSpec] {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            // Generate const array for this Chip type
            code.push_str(&format!("            ChipType::Chip{} => &[\n", type_name));

            // Sort control lines by name for consistency
            let mut control_lines: Vec<_> = chip_type.control.iter().collect();
            control_lines.sort_by_key(|(name, _)| *name);

            for (name, control) in control_lines {
                let line_type = match control.line_type {
                    ControlLineType::Configurable => "ControlLineType::Configurable",
                    ControlLineType::FixedActiveLow => "ControlLineType::FixedActiveLow",
                };
                code.push_str(&format!(
                    "                ControlLineSpec {{ name: \"{}\", pin: {}, line_type: {} }},\n",
                    name, control.pin, line_type
                ));
            }

            code.push_str("            ],\n");
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_programming_pins_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get programming pin specifications\n");
    code.push_str("    ///\n");
    code.push_str(
        "    /// Returns specifications for programming-related pins (Vpp, /PGM) and their\n",
    );
    code.push_str(
        "    /// required states during normal read operations. Returns None if the Chip type\n",
    );
    code.push_str("    /// has no programming pins (e.g., 27512 where pin 1 is A15).\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::chip::{ChipType, ProgrammingPinState};\n");
    code.push_str("    ///\n");
    code.push_str("    /// let pins = ChipType::Chip27128.programming_pins().unwrap();\n");
    code.push_str("    /// assert_eq!(pins.len(), 2);\n");
    code.push_str("    /// let vpp = pins.iter().find(|p| p.name == \"vpp\").unwrap();\n");
    code.push_str("    /// assert_eq!(vpp.read_state, ProgrammingPinState::Vcc);\n");
    code.push_str("    /// ```\n");
    code.push_str(
        "    pub const fn programming_pins(&self) -> Option<&'static [ProgrammingPinSpec]> {\n",
    );
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            if let Some(ref prog) = chip_type.programming {
                let mut specs = Vec::new();

                if let Some(ref vpp) = prog.vpp {
                    let state = match vpp.read_state.as_str() {
                        "vcc" => "ProgrammingPinState::Vcc",
                        "high" => "ProgrammingPinState::High",
                        "low" => "ProgrammingPinState::Low",
                        "chip_select" => "ProgrammingPinState::ChipSelect",
                        "x" => "ProgrammingPinState::Ignored",
                        "word_size" => "ProgrammingPinState::WordSize",
                        _ => panic!("Invalid read state"),
                    };
                    specs.push(format!(
                        "ProgrammingPinSpec {{ name: \"vpp\", pin: {}, read_state: {} }}",
                        vpp.pin, state
                    ));
                }

                if let Some(ref pgm) = prog.pgm {
                    let state = match pgm.read_state.as_str() {
                        "vcc" => "ProgrammingPinState::Vcc",
                        "high" => "ProgrammingPinState::High",
                        "low" => "ProgrammingPinState::Low",
                        "chip_select" => "ProgrammingPinState::ChipSelect",
                        "x" => "ProgrammingPinState::Ignored",
                        "word_size" => "ProgrammingPinState::WordSize",
                        _ => panic!("Invalid read state"),
                    };
                    specs.push(format!(
                        "ProgrammingPinSpec {{ name: \"pgm\", pin: {}, read_state: {} }}",
                        pgm.pin, state
                    ));
                }

                if !specs.is_empty() {
                    code.push_str(&format!(
                        "            ChipType::Chip{} => Some(&[\n",
                        type_name
                    ));
                    for spec in specs {
                        code.push_str(&format!("                {},\n", spec));
                    }
                    code.push_str("            ]),\n");
                } else {
                    code.push_str(&format!("            ChipType::Chip{} => None,\n", type_name));
                }
            } else {
                code.push_str(&format!("            ChipType::Chip{} => None,\n", type_name));
            }
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_power_pins_method(config: &ChipTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get power pin specifications\n");
    // ... (keep the existing doc comments) ...
    code.push_str("    pub const fn power_pins(&self) -> &'static [PowerPinSpec] {\n");
    code.push_str("        match self {\n");

    for (type_name, _chip_type) in get_sorted_chip_types(config) {
        if let Some(chip_type) = config.chip_types.get(type_name) {
            code.push_str(&format!("            ChipType::Chip{} => &[\n", type_name));

            if let Some(ref power_pins) = chip_type.power {
                for power_pin in power_pins {
                    let name = power_pin.name.to_lowercase();
                    if name == "gnd" || name == "vcc" {
                        code.push_str(&format!(
                            "                PowerPinSpec {{ name: \"{}\", pin: {} }},\n",
                            name, power_pin.pin
                        ));
                    }
                }
            }

            code.push_str("            ],\n");
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}
